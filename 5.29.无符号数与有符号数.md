[TOC]



## 1.无符号数与有符号数

 ### 1.1有符号数转化为无符号数

```c
int a = -100;
unsigned int b = a;
```

发生的转化:

1.先将a的二进制数表示出来: 1000 0000 0000 0000 0000 0000 0110 0100

2.计算此二进制的补码(除符号位外,取反+1):

 1111 1111 1111 1111 1111 1111 1001 1100

3.直接赋值给b,b的值即为1111 1111 1111 1111 1111 1111 1001 1100(dec 4294967196)

**注:负数在计算机中以补码的型式存储**

**若a为正值,则直接赋值**

### 1.2 整型提升

**64位系统和32位系统中int都占据4个字节,但是64位系统中long占据8个字节,而32位系统中long占据4个字节**



**我们使用64位系统**

如:int转long 

十进制100的二进制值: 0000 1110 0100

```c
int a = 100;
long b = a;
```

整型提升:

若a为100,则在最高位补0 :  .... 0000 0000 1110 0100

若a为-100(1110 0100),则在补码(1111 1111 1111 1111 1111 1111 1001 1100)的最高位补1:

## 2.32位系统中的汇编语言

### 2.1 leal(src,des,num)

含义: src = src + des*num;

### 2.2 sub和add

sub指减法,用法: sub desc src ,**含义: src= src - desc**

add指加法,用法: add desc src **含义:src=src+desc**

### 2.3 寄存器

在32位的x86架构中，常用的寄存器及其用途如下：

1. 通用寄存器：
   - EAX（累加器）：用于存放函数返回值、算术运算的结果。
   - EBX（基址寄存器）：用于存放数据的基地址。
   - ECX（计数器）：用于循环计数、字符串操作等。
   - EDX（数据寄存器）：用于存放数据、I/O端口地址。
   - ESI（源索引寄存器）：用于字符串操作的源地址。
   - EDI（目的索引寄存器）：用于字符串操作的目的地址。
   - ESP（栈指针寄存器）：指向栈顶的地址。
   - EBP（基址指针寄存器）：用于指向函数栈帧的基址。

2. 段寄存器：
   - CS（代码段寄存器）：存放代码段的选择子。
   - DS（数据段寄存器）：存放数据段的选择子。
   - SS（堆栈段寄存器）：存放堆栈段的选择子。
   - ES（附加段寄存器）：可用于存放附加的数据段选择子。

3. 标志寄存器：
   - EFLAGS：存放各种状态和控制标志位，例如条件判断、进位标志、溢出标志等。

除了上述常用的寄存器外，还有一些特殊用途的寄存器，如：
- EIP（指令指针寄存器）：存放下一条要执行的指令地址。
- CR0（控制寄存器）：用于控制处理器的各种操作和特性。
- DR0-DR7（调试寄存器）：用于设置断点和调试操作。

需要注意的是，上述寄存器名称是在32位模式下的命名，64位模式下的寄存器名称有所变化。此外，各个寄存器的具体用途和约定可能会因不同的编程语言、操作系统和编译器而有所差异。

### 2.4.mov

`mov` 指令的语法通常是 `mov <源操作数>, <目的操作数>`，其中 `<目的操作数>` 是要接收数据的位置，而 `<源操作数>` 是要复制的数据来源。

例如，`mov eax, ebx` 表示将寄存器 `eax` 中的值复制到寄存器 `ebx` 中。这将使 `eax` 的内容与 `ebx` 相同。